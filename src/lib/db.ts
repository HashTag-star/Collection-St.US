
import Database from 'better-sqlite3';
import type { Product, User, Order, OrderItem, ShippingAddress, NewsletterSubscription } from './types';

// In a production Firebase environment, you might need a writable path.
// For local dev and some App Hosting setups, this might be fine.
// If deployed to a read-only filesystem, this will fail.
const db = new Database('dev.db');
console.log('SQLite database initialized at dev.db');

// Initial data (IDs will be auto-generated by SQLite)
const initialProductsData: Omit<Product, 'id'>[] = [
  { name: 'Elegant Evening Gown', price: 250.00, description: 'A stunning full-length gown perfect for formal events. Made with high-quality silk and intricate lace details. Features a flattering A-line silhouette.', category: 'Dresses', imageUrls: ['https://placehold.co/800x1200.png', 'https://placehold.co/600x800.png', 'https://placehold.co/400x600.png'], stock: 15, status: 'Active', rating: 4.5, reviews: 25, dataAiHint: 'evening gown', sizes: ['S', 'M', 'L', 'XL'] },
  { name: 'Casual Summer Dress', price: 120.00, description: 'Light and airy summer dress, ideal for warm weather. Crafted from breathable cotton with a vibrant floral print.', category: 'Dresses', imageUrls: ['https://placehold.co/600x800.png', 'https://placehold.co/400x600.png'], stock: 30, status: 'Active', rating: 4.2, reviews: 18, dataAiHint: 'summer dress', sizes: ['XS', 'S', 'M'] },
  { name: 'Chic Office Blouse', price: 90.00, description: 'A stylish and professional blouse for the modern working woman. Made from a comfortable, wrinkle-resistant fabric.', category: 'Tops', imageUrls: ['https://placehold.co/600x800.png', 'https://placehold.co/400x600.png'], stock: 32, status: 'Active', rating: 4.8, reviews: 30, dataAiHint: 'office blouse', sizes: ['S', 'M', 'L'] },
  { name: 'Silk Scarf Collection', price: 75.00, description: 'Luxurious silk scarves in various prints. Adds a touch of elegance to any outfit.', category: 'Accessories', imageUrls: ['https://placehold.co/600x800.png'], stock: 50, status: 'Active', rating: 4.0, reviews: 10, dataAiHint: 'silk scarf', sizes: undefined },
  { name: 'Denim Jeans', price: 180.00, description: 'Comfortable and stylish denim jeans, perfect for casual wear. Available in multiple fits.', category: 'Bottoms', imageUrls: ['https://placehold.co/600x800.png'], stock: 20, status: 'Active', rating: 4.3, reviews: 22, dataAiHint: 'denim jeans', sizes: ['28', '30', '32', '34', '36'] },
  { name: 'Leather Handbag', price: 350.00, description: 'A high-quality leather handbag with multiple compartments. Durable and fashionable.', category: 'Accessories', imageUrls: ['https://placehold.co/600x800.png'], stock: 8, status: 'Active', rating: 4.9, reviews: 40, dataAiHint: 'leather handbag', sizes: undefined },
  { name: 'Summer Maxi Dress (Draft)', price: 180.00, description: 'Beautiful maxi dress for summer occasions. Made from lightweight fabric.', category: 'Dresses', imageUrls: ['https://placehold.co/600x800.png'], stock: 0, status: 'Draft', rating: 3.9, reviews: 5, dataAiHint: 'maxi dress', sizes: ['S', 'M', 'L'] },
];

const initialUsersData: Omit<User, 'id'>[] = [
    { fullName: 'Festus Us', email: 'festus@example.com', password: 'password123', avatarUrl: 'https://placehold.co/100x100.png?text=FU' },
    { fullName: 'Ama Serwaa', email: 'ama@example.com', password: 'password123', avatarUrl: 'https://placehold.co/100x100.png?text=AS' },
    { fullName: 'Admin User', email: 'admin@stus.com', password: 'adminpassword', avatarUrl: 'https://placehold.co/100x100.png?text=AU' },
];

const festusUsShippingAddress: ShippingAddress = {
  firstName: 'Festus',
  lastName: 'Us',
  address: '123 Main St',
  city: 'Accra',
  phone: '0241112222',
};

const amaSerwaaShippingAddress: ShippingAddress = {
  firstName: 'Ama',
  lastName: 'Serwaa',
  address: '456 Side Rd',
  city: 'Kumasi',
  phone: '0243334444',
};

const initialOrdersData: Omit<Order, 'id' | 'items'>[] = [
  { userId: '1', orderDate: '2024-05-01T10:00:00Z', totalAmount: 250.00, status: 'Delivered', paymentStatus: 'Paid', shippingAddress: festusUsShippingAddress, customerFullName: 'Festus Us', customerEmail: 'festus@example.com' },
  { userId: '1', orderDate: '2024-05-10T11:30:00Z', totalAmount: 90.00, status: 'Shipped', paymentStatus: 'Paid', shippingAddress: festusUsShippingAddress, customerFullName: 'Festus Us', customerEmail: 'festus@example.com'},
  { userId: '2', orderDate: '2024-05-15T14:15:00Z', totalAmount: 75.00, status: 'Processing', paymentStatus: 'Pending', shippingAddress: amaSerwaaShippingAddress, customerFullName: 'Ama Serwaa', customerEmail: 'ama@example.com' },
  { userId: '1', orderDate: '2024-06-01T09:00:00Z', totalAmount: 180.00, status: 'Delivered', paymentStatus: 'Paid', shippingAddress: festusUsShippingAddress, customerFullName: 'Festus Us', customerEmail: 'festus@example.com' },
];

// Note: The `productName` here is used to look up actual product ID from the DB.
const initialOrderItemsData: Omit<OrderItem, 'id' | 'productId' | 'orderId'>[] = [
  // Order 1 (Festus Us - Elegant Evening Gown)
  { productName: 'Elegant Evening Gown', productImageUrl: initialProductsData[0].imageUrls[0], quantity: 1, priceAtPurchase: 250.00, size: 'M' },
  // Order 2 (Festus Us - Chic Office Blouse)
  { productName: 'Chic Office Blouse', productImageUrl: initialProductsData[2].imageUrls[0], quantity: 1, priceAtPurchase: 90.00, size: 'L' },
  // Order 3 (Ama Serwaa - Silk Scarf)
  { productName: 'Silk Scarf Collection', productImageUrl: initialProductsData[3].imageUrls[0], quantity: 1, priceAtPurchase: 75.00, size: undefined },
  // Order 4 (Festus Us - Denim Jeans)
  { productName: 'Denim Jeans', productImageUrl: initialProductsData[4].imageUrls[0], quantity: 1, priceAtPurchase: 180.00, size: '32' },
];


const initialStoreSettings: Record<string, string | boolean> = {
  storeName: 'St.Us Collections',
  storeEmail: 'support@stus.com',
  storePhone: '+233 24 123 4567',
  storeAddress: '123 Fashion Ave, Accra, Ghana',
  momoNumber: '',
  vodafoneCash: '',
  enableCardPayments: false,
  standardShippingRate: '15.00',
  freeShippingThreshold: '',
  localPickup: false,
  pickupAddress: '',
  adminNewOrder: true,
  adminLowStock: false,
  customerOrderConfirmation: true,
  customerShippingUpdate: true,
  customerOrderDelivered: false,
  notificationEmail: 'admin@stus.com',
};


function initializeDatabase() {
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      fullName TEXT NOT NULL,
      email TEXT NOT NULL UNIQUE,
      password TEXT NOT NULL, -- In a real app, this would be hashed
      avatarUrl TEXT
    );

    CREATE TABLE IF NOT EXISTS products (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      price REAL NOT NULL,
      description TEXT NOT NULL,
      category TEXT NOT NULL,
      imageUrls TEXT, -- Stored as JSON string
      stock INTEGER NOT NULL,
      status TEXT NOT NULL CHECK(status IN ('Active', 'Draft')),
      rating REAL,
      reviews INTEGER,
      dataAiHint TEXT NOT NULL,
      sizes TEXT -- Stored as JSON string
    );

    CREATE TABLE IF NOT EXISTS store_settings (
      key TEXT PRIMARY KEY,
      value TEXT
    );

    CREATE TABLE IF NOT EXISTS orders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId INTEGER NOT NULL, 
        orderDate TEXT NOT NULL, 
        totalAmount REAL NOT NULL,
        status TEXT NOT NULL CHECK(status IN ('Pending Payment', 'Processing', 'Shipped', 'Delivered', 'Cancelled')),
        paymentStatus TEXT NOT NULL CHECK(paymentStatus IN ('Pending', 'Paid', 'Failed', 'Refunded')),
        shippingAddress TEXT NOT NULL, 
        customerFullName TEXT, 
        customerEmail TEXT, 
        FOREIGN KEY (userId) REFERENCES users(id)
    );

    CREATE TABLE IF NOT EXISTS order_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        orderId INTEGER NOT NULL, 
        productId INTEGER NOT NULL, 
        productName TEXT NOT NULL,
        productImageUrl TEXT,
        quantity INTEGER NOT NULL,
        priceAtPurchase REAL NOT NULL,
        size TEXT, 
        FOREIGN KEY (orderId) REFERENCES orders(id),
        FOREIGN KEY (productId) REFERENCES products(id)
    );

    CREATE TABLE IF NOT EXISTS newsletter_subscriptions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT NOT NULL UNIQUE,
        subscribedAt TEXT NOT NULL 
    );
  `);

  const userCount = db.prepare('SELECT COUNT(*) as count FROM users').get() as { count: number };
  if (userCount.count === 0) {
    const insertUser = db.prepare(
      'INSERT INTO users (fullName, email, password, avatarUrl) VALUES (@fullName, @email, @password, @avatarUrl)'
    );
    db.transaction(() => {
      for (const user of initialUsersData) {
        insertUser.run(user);
      }
    })();
    console.log('Initial users seeded.');
  }

  const productCount = db.prepare('SELECT COUNT(*) as count FROM products').get() as { count: number };
  if (productCount.count === 0) {
    const insertProduct = db.prepare(
      'INSERT INTO products (name, price, description, category, imageUrls, stock, status, rating, reviews, dataAiHint, sizes) VALUES (@name, @price, @description, @category, @imageUrls, @stock, @status, @rating, @reviews, @dataAiHint, @sizes)'
    );
    db.transaction(() => {
      for (const product of initialProductsData) {
        insertProduct.run({
          ...product,
          imageUrls: JSON.stringify(product.imageUrls || []),
          sizes: product.sizes ? JSON.stringify(product.sizes) : null,
          rating: product.rating ?? null,
          reviews: product.reviews ?? null,
        });
      }
    })();
    console.log('Initial products seeded.');
  }

  const settingsCount = db.prepare('SELECT COUNT(*) as count FROM store_settings').get() as { count: number };
  if (settingsCount.count === 0) {
    const insertSetting = db.prepare('INSERT INTO store_settings (key, value) VALUES (@key, @value)');
    db.transaction(() => {
      for (const [key, value] of Object.entries(initialStoreSettings)) {
        insertSetting.run({ key, value: String(value) });
      }
    })();
    console.log('Initial store settings seeded.');
  }

  const orderCount = db.prepare('SELECT COUNT(*) as count FROM orders').get() as { count: number };
  if (orderCount.count === 0) {
    const insertOrder = db.prepare(
      'INSERT INTO orders (userId, orderDate, totalAmount, status, paymentStatus, shippingAddress, customerFullName, customerEmail) VALUES (@userId, @orderDate, @totalAmount, @status, @paymentStatus, @shippingAddress, @customerFullName, @customerEmail)'
    );
    const insertOrderItem = db.prepare(
      'INSERT INTO order_items (orderId, productId, productName, productImageUrl, quantity, priceAtPurchase, size) VALUES (@orderId, @productId, @productName, @productImageUrl, @quantity, @priceAtPurchase, @size)'
    );

    const allProductsFromDB = db.prepare('SELECT id, name FROM products').all() as { id: number; name: string }[];
    const productMapByName = new Map(allProductsFromDB.map(p => [p.name, p.id]));
    
    const usersFromDB = db.prepare('SELECT id, email FROM users').all() as {id: number; email: string}[];
    const userEmailToIdMap = new Map(usersFromDB.map(u => [u.email, u.id]));

    const orderIdMapping: Record<string, number> = {}; 

    db.transaction(() => {
      initialOrdersData.forEach((order, index) => {
        const actualUserId = userEmailToIdMap.get(order.customerEmail as string);
        if (!actualUserId) {
          console.warn(`Could not find user ID for email ${order.customerEmail} when seeding order ${order.userId}. Skipping order.`);
          return;
        }

        const info = insertOrder.run({
            ...order,
            userId: actualUserId,
            shippingAddress: JSON.stringify(order.shippingAddress)
        });
        orderIdMapping[order.userId + '-' + index] = info.lastInsertRowid as number; // Use a more unique key if userId can repeat
      });

      initialOrderItemsData.forEach((item, idx) => {
          let targetMockOrderKey: string | undefined;
          // Map initialOrderItemsData index to initialOrdersData index if they correspond 1-to-1
          // This mapping logic needs to be robust based on how mock items relate to mock orders
          if (idx === 0 && initialOrdersData[0]) targetMockOrderKey = initialOrdersData[0].userId + '-0'; 
          else if (idx === 1 && initialOrdersData[1]) targetMockOrderKey = initialOrdersData[1].userId + '-1';
          else if (idx === 2 && initialOrdersData[2]) targetMockOrderKey = initialOrdersData[2].userId + '-2';
          else if (idx === 3 && initialOrdersData[3]) targetMockOrderKey = initialOrdersData[3].userId + '-3';
          
          const actualOrderId = targetMockOrderKey ? orderIdMapping[targetMockOrderKey] : undefined;
          const actualProductId = productMapByName.get(item.productName);

          if (actualOrderId && actualProductId !== undefined) {
            insertOrderItem.run({
                orderId: actualOrderId,
                productId: actualProductId,
                productName: item.productName,
                productImageUrl: item.productImageUrl,
                quantity: item.quantity,
                priceAtPurchase: item.priceAtPurchase,
                size: item.size || null,
            });
          } else {
            console.warn(`Could not seed order item for product "${item.productName}". Mapped Order ID: ${actualOrderId}, Product ID: ${actualProductId}`);
          }
      });
    })();
    console.log('Initial orders and order items seeded.');
  }
}

initializeDatabase();

export default db;
    