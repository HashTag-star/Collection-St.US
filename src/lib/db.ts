
import Database from 'better-sqlite3';
import type { Product, User, Order, OrderItem, ShippingAddress, NewsletterSubscription } from './types';

// In a production Firebase environment, you might need a writable path.
// For local dev and some App Hosting setups, this might be fine.
// If deployed to a read-only filesystem, this will fail.
const db = new Database('dev.db');
console.log('SQLite database initialized at dev.db');

// Initial data (IDs will be auto-generated by SQLite)
const initialProductsData: Omit<Product, 'id'>[] = [
  { name: 'Elegant Evening Gown', price: 250.00, description: 'A stunning full-length gown perfect for formal events. Made with high-quality silk and intricate lace details. Features a flattering A-line silhouette.', category: 'Dresses', imageUrls: ['https://placehold.co/800x1200.png', 'https://placehold.co/600x800.png', 'https://placehold.co/400x600.png'], stock: 15, status: 'Active', rating: 4.5, reviews: 25, dataAiHint: 'evening gown', sizes: ['S', 'M', 'L', 'XL'] },
  { name: 'Casual Summer Dress', price: 120.00, description: 'Light and airy summer dress, ideal for warm weather. Crafted from breathable cotton with a vibrant floral print.', category: 'Dresses', imageUrls: ['https://placehold.co/600x800.png', 'https://placehold.co/400x600.png'], stock: 30, status: 'Active', rating: 4.2, reviews: 18, dataAiHint: 'summer dress', sizes: ['XS', 'S', 'M'] },
  { name: 'Chic Office Blouse', price: 90.00, description: 'A stylish and professional blouse for the modern working woman. Made from a comfortable, wrinkle-resistant fabric.', category: 'Tops', imageUrls: ['https://placehold.co/600x800.png', 'https://placehold.co/400x600.png'], stock: 32, status: 'Active', rating: 4.8, reviews: 30, dataAiHint: 'office blouse', sizes: ['S', 'M', 'L'] },
  { name: 'Silk Scarf Collection', price: 75.00, description: 'Luxurious silk scarves in various prints. Adds a touch of elegance to any outfit.', category: 'Accessories', imageUrls: ['https://placehold.co/600x800.png'], stock: 50, status: 'Active', rating: 4.0, reviews: 10, dataAiHint: 'silk scarf', sizes: undefined },
  { name: 'Denim Jeans', price: 180.00, description: 'Comfortable and stylish denim jeans, perfect for casual wear. Available in multiple fits.', category: 'Bottoms', imageUrls: ['https://placehold.co/600x800.png'], stock: 20, status: 'Active', rating: 4.3, reviews: 22, dataAiHint: 'denim jeans', sizes: ['28', '30', '32', '34', '36'] },
  { name: 'Leather Handbag', price: 350.00, description: 'A high-quality leather handbag with multiple compartments. Durable and fashionable.', category: 'Accessories', imageUrls: ['https://placehold.co/600x800.png'], stock: 8, status: 'Active', rating: 4.9, reviews: 40, dataAiHint: 'leather handbag', sizes: undefined },
  { name: 'Summer Maxi Dress (Draft)', price: 180.00, description: 'Beautiful maxi dress for summer occasions. Made from lightweight fabric.', category: 'Dresses', imageUrls: ['https://placehold.co/600x800.png'], stock: 0, status: 'Draft', rating: 3.9, reviews: 5, dataAiHint: 'maxi dress', sizes: ['S', 'M', 'L'] },
];

const initialUsersData: Omit<User, 'id'>[] = [
    { fullName: 'Festus Us', email: 'festus@example.com', password: 'password123', avatarUrl: 'https://placehold.co/100x100.png' },
    { fullName: 'Ama Serwaa', email: 'ama@example.com', password: 'password123', avatarUrl: 'https://placehold.co/100x100.png' },
];

const festusUsShippingAddress: ShippingAddress = {
  firstName: 'Festus',
  lastName: 'Us',
  address: '123 Main St',
  city: 'Accra',
  phone: '0241112222',
};

const amaSerwaaShippingAddress: ShippingAddress = {
  firstName: 'Ama',
  lastName: 'Serwaa',
  address: '456 Side Rd',
  city: 'Kumasi',
  phone: '0243334444',
};

const initialOrdersData: Omit<Order, 'id' | 'items'>[] = [
  { userId: '1', orderDate: '2024-05-01T10:00:00Z', totalAmount: 250.00, status: 'Delivered', paymentStatus: 'Paid', shippingAddress: festusUsShippingAddress, customerFullName: 'Festus Us', customerEmail: 'festus@example.com' },
  { userId: '1', orderDate: '2024-05-10T11:30:00Z', totalAmount: 90.00, status: 'Shipped', paymentStatus: 'Paid', shippingAddress: festusUsShippingAddress, customerFullName: 'Festus Us', customerEmail: 'festus@example.com'},
  { userId: '2', orderDate: '2024-05-15T14:15:00Z', totalAmount: 75.00, status: 'Processing', paymentStatus: 'Pending', shippingAddress: amaSerwaaShippingAddress, customerFullName: 'Ama Serwaa', customerEmail: 'ama@example.com' },
  { userId: '1', orderDate: '2024-06-01T09:00:00Z', totalAmount: 180.00, status: 'Delivered', paymentStatus: 'Paid', shippingAddress: festusUsShippingAddress, customerFullName: 'Festus Us', customerEmail: 'festus@example.com' },
];

// Note: The `productName` here is used to look up actual product ID from the DB.
const initialOrderItemsData: Omit<OrderItem, 'id' | 'productId' | 'orderId'>[] = [
  // Order 1 (Festus Us - Elegant Evening Gown)
  { productName: 'Elegant Evening Gown', productImageUrl: initialProductsData[0].imageUrls[0], quantity: 1, priceAtPurchase: 250.00, size: 'M' },
  // Order 2 (Festus Us - Chic Office Blouse)
  { productName: 'Chic Office Blouse', productImageUrl: initialProductsData[2].imageUrls[0], quantity: 1, priceAtPurchase: 90.00, size: 'L' },
  // Order 3 (Ama Serwaa - Silk Scarf)
  { productName: 'Silk Scarf Collection', productImageUrl: initialProductsData[3].imageUrls[0], quantity: 1, priceAtPurchase: 75.00, size: undefined },
  // Order 4 (Festus Us - Denim Jeans)
  { productName: 'Denim Jeans', productImageUrl: initialProductsData[4].imageUrls[0], quantity: 1, priceAtPurchase: 180.00, size: '32' },
];


const initialStoreSettings: Record<string, string | boolean> = {
  storeName: 'St.Us Collections',
  storeEmail: 'support@stus.com',
  storePhone: '+233 24 123 4567',
  storeAddress: '123 Fashion Ave, Accra, Ghana',
  momoNumber: '',
  vodafoneCash: '',
  enableCardPayments: false,
  standardShippingRate: '15.00',
  freeShippingThreshold: '',
  localPickup: false,
  pickupAddress: '',
  adminNewOrder: true,
  adminLowStock: false,
  customerOrderConfirmation: true,
  customerShippingUpdate: true,
  customerOrderDelivered: false,
  notificationEmail: 'admin@stus.com',
};


function initializeDatabase() {
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      fullName TEXT NOT NULL,
      email TEXT NOT NULL UNIQUE,
      password TEXT NOT NULL, -- In a real app, this would be hashed
      avatarUrl TEXT
    );

    CREATE TABLE IF NOT EXISTS products (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      price REAL NOT NULL,
      description TEXT NOT NULL,
      category TEXT NOT NULL,
      imageUrls TEXT, -- Stored as JSON string
      stock INTEGER NOT NULL,
      status TEXT NOT NULL CHECK(status IN ('Active', 'Draft')),
      rating REAL,
      reviews INTEGER,
      dataAiHint TEXT NOT NULL,
      sizes TEXT -- Stored as JSON string
    );

    CREATE TABLE IF NOT EXISTS store_settings (
      key TEXT PRIMARY KEY,
      value TEXT
    );

    CREATE TABLE IF NOT EXISTS orders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId INTEGER NOT NULL, -- Changed from TEXT to INTEGER for foreign key
        orderDate TEXT NOT NULL, -- ISO Date String
        totalAmount REAL NOT NULL,
        status TEXT NOT NULL CHECK(status IN ('Pending Payment', 'Processing', 'Shipped', 'Delivered', 'Cancelled')),
        paymentStatus TEXT NOT NULL CHECK(paymentStatus IN ('Pending', 'Paid', 'Failed', 'Refunded')),
        shippingAddress TEXT NOT NULL, -- JSON string
        customerFullName TEXT, -- Denormalized for convenience
        customerEmail TEXT, -- Denormalized for convenience
        FOREIGN KEY (userId) REFERENCES users(id)
    );

    CREATE TABLE IF NOT EXISTS order_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        orderId INTEGER NOT NULL, -- Changed from TEXT to INTEGER
        productId INTEGER NOT NULL, -- Changed from TEXT to INTEGER
        productName TEXT NOT NULL,
        productImageUrl TEXT,
        quantity INTEGER NOT NULL,
        priceAtPurchase REAL NOT NULL,
        size TEXT, -- Optional
        FOREIGN KEY (orderId) REFERENCES orders(id),
        FOREIGN KEY (productId) REFERENCES products(id)
    );

    CREATE TABLE IF NOT EXISTS newsletter_subscriptions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT NOT NULL UNIQUE,
        subscribedAt TEXT NOT NULL -- ISO Date String
    );
  `);

  // Seed initial users if users table is empty
  const userCount = db.prepare('SELECT COUNT(*) as count FROM users').get() as { count: number };
  if (userCount.count === 0) {
    const insertUser = db.prepare(
      'INSERT INTO users (fullName, email, password, avatarUrl) VALUES (@fullName, @email, @password, @avatarUrl)'
    );
    db.transaction(() => {
      for (const user of initialUsersData) {
        insertUser.run(user);
      }
    })();
    console.log('Initial users seeded.');
  }

  // Seed initial products if products table is empty
  const productCount = db.prepare('SELECT COUNT(*) as count FROM products').get() as { count: number };
  if (productCount.count === 0) {
    const insertProduct = db.prepare(
      'INSERT INTO products (name, price, description, category, imageUrls, stock, status, rating, reviews, dataAiHint, sizes) VALUES (@name, @price, @description, @category, @imageUrls, @stock, @status, @rating, @reviews, @dataAiHint, @sizes)'
    );
    db.transaction(() => {
      for (const product of initialProductsData) {
        insertProduct.run({
          ...product,
          imageUrls: JSON.stringify(product.imageUrls || []),
          sizes: product.sizes ? JSON.stringify(product.sizes) : null,
          rating: product.rating ?? null,
          reviews: product.reviews ?? null,
        });
      }
    })();
    console.log('Initial products seeded.');
  }

  // Seed initial store settings if settings table is empty
  const settingsCount = db.prepare('SELECT COUNT(*) as count FROM store_settings').get() as { count: number };
  if (settingsCount.count === 0) {
    const insertSetting = db.prepare('INSERT INTO store_settings (key, value) VALUES (@key, @value)');
    db.transaction(() => {
      for (const [key, value] of Object.entries(initialStoreSettings)) {
        insertSetting.run({ key, value: String(value) });
      }
    })();
    console.log('Initial store settings seeded.');
  }

  // Seed initial orders and order items if tables are empty
  const orderCount = db.prepare('SELECT COUNT(*) as count FROM orders').get() as { count: number };
  if (orderCount.count === 0) {
    const insertOrder = db.prepare(
      'INSERT INTO orders (userId, orderDate, totalAmount, status, paymentStatus, shippingAddress, customerFullName, customerEmail) VALUES (@userId, @orderDate, @totalAmount, @status, @paymentStatus, @shippingAddress, @customerFullName, @customerEmail)'
    );
    const insertOrderItem = db.prepare(
      'INSERT INTO order_items (orderId, productId, productName, productImageUrl, quantity, priceAtPurchase, size) VALUES (@orderId, @productId, @productName, @productImageUrl, @quantity, @priceAtPurchase, @size)'
    );

    const allProductsFromDB = db.prepare('SELECT id, name FROM products').all() as { id: number; name: string }[];
    const productMapByName = new Map(allProductsFromDB.map(p => [p.name, p.id]));

    const orderIdMapping: Record<string, number> = {}; // To map mock order "ID" strings to actual DB IDs

    db.transaction(() => {
      // Insert orders and get their actual IDs
      // We map mock user "ID" (like '1' for festus) to actual user ID from DB
      const usersFromDB = db.prepare('SELECT id, email FROM users').all() as {id: number; email: string}[];
      const userEmailToIdMap = new Map(usersFromDB.map(u => [u.email, u.id]));


      initialOrdersData.forEach((order, index) => {
        // Find the actual userId from the userEmailToIdMap
        const actualUserId = userEmailToIdMap.get(order.customerEmail as string);
        if (!actualUserId) {
          console.warn(`Could not find user ID for email ${order.customerEmail} when seeding order. Skipping order.`);
          return;
        }

        const info = insertOrder.run({
            ...order,
            userId: actualUserId, // Use actual user ID
            shippingAddress: JSON.stringify(order.shippingAddress)
        });
        // The mock order's 'userId' in initialOrdersData was used as a key,
        // which doesn't directly map to our order item mock structure.
        // Instead, we'll use the index as a key for now for simplicity in mock data mapping.
        orderIdMapping[String(index + 1)] = info.lastInsertRowid as number;
      });


      // Insert order items, mapping to the generated order IDs and looking up product IDs
      initialOrderItemsData.forEach((item, idx) => {
          // This assumes initialOrderItemsData directly corresponds to initialOrdersData items
          // by their array index (1-based for the mock 'orderId' field in the old data)
          // Let's find which order this item belongs to.
          // This part is tricky because the old mock `item.orderId` doesn't exist in new `initialOrderItemsData`.
          // We'll assume for mock purposes that the first item in initialOrderItemsData belongs to the first order, etc.
          // Or, more reliably, we need a way to link items to orders in the mock data itself.
          // Let's assume initialOrderItemsData[i] belongs to initialOrdersData[i].
          // This requires initialOrderItemsData and initialOrdersData to be structured such that items correspond.
          // A better mock data structure would have items nested within orders.

          // Given the current structure, we need to be careful. Let's map based on a logical grouping if possible.
          // For this example, let's hardcode the mapping for simplicity of this fix stage:
          // Item 0 -> Order 1 (initialOrdersData[0] -> orderIdMapping['1'])
          // Item 1 -> Order 2 (initialOrdersData[1] -> orderIdMapping['2'])
          // Item 2 -> Order 3 (initialOrdersData[2] -> orderIdMapping['3'])
          // Item 3 -> Order 4 (initialOrdersData[3] -> orderIdMapping['4'])
          
          let targetMockOrderIdKey: string | undefined;
          if (idx === 0) targetMockOrderIdKey = '1'; // First item maps to mock order '1'
          else if (idx === 1) targetMockOrderIdKey = '2'; // Second item to mock order '2'
          else if (idx === 2) targetMockOrderIdKey = '3'; // Third item to mock order '3'
          else if (idx === 3) targetMockOrderIdKey = '4'; // Fourth item to mock order '4'


          const actualOrderId = targetMockOrderIdKey ? orderIdMapping[targetMockOrderIdKey] : undefined;
          const actualProductId = productMapByName.get(item.productName);

          if (actualOrderId && actualProductId !== undefined) {
            insertOrderItem.run({
                orderId: actualOrderId,
                productId: actualProductId,
                productName: item.productName,
                productImageUrl: item.productImageUrl,
                quantity: item.quantity,
                priceAtPurchase: item.priceAtPurchase,
                size: item.size || null,
            });
          } else {
            console.warn(`Could not seed order item for product "${item.productName}". Order ID: ${actualOrderId}, Product ID: ${actualProductId}`);
          }
      });
    })();
    console.log('Initial orders and order items seeded.');
  }
}

// Ensure database is initialized when this module is first imported
initializeDatabase();

export default db;
